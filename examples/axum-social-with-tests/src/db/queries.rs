/// This file is @generated by sqlc-gen-rust.
#[derive(Debug, Clone, sqlx::FromRow)]
pub struct CreatePostRow {
    pub post_id: uuid::Uuid,
    pub username: String,
    pub content: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}
pub async fn create_post<'e, E>(
    db: E,
    user_id: uuid::Uuid,
    content: String,
) -> Result<CreatePostRow, sqlx::Error>
where
    E: sqlx::Executor<'e, Database = sqlx::Postgres>,
{
    let rec: CreatePostRow = sqlx::query_as(
            "
with inserted_post as (
    insert into post(user_id, content)
    values ($1, $2)
    returning post_id, user_id, content, created_at
)
select post_id, username, content, created_at
from inserted_post
inner join \"user\" using (user_id)
",
        )
        .bind(user_id)
        .bind(content)
        .fetch_one(db)
        .await?;
    Ok(rec)
}
#[derive(Debug, Clone, sqlx::FromRow)]
pub struct GetPostsRow {
    pub post_id: uuid::Uuid,
    pub username: String,
    pub content: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}
pub async fn get_posts<'e, E>(db: E) -> Result<Vec<GetPostsRow>, sqlx::Error>
where
    E: sqlx::Executor<'e, Database = sqlx::Postgres>,
{
    let rec: Vec<GetPostsRow> = sqlx::query_as(
            "
select post_id, username, content, created_at
from post
inner join \"user\" using (user_id)
order by created_at desc
",
        )
        .fetch_all(db)
        .await?;
    Ok(rec)
}
#[derive(Debug, Clone, sqlx::FromRow)]
pub struct CreateCommentInfo {
    pub user_id: uuid::Uuid,
    pub post_id: uuid::Uuid,
    pub content: String,
}
#[derive(Debug, Clone, sqlx::FromRow)]
pub struct CreateCommentRow {
    pub comment_id: uuid::Uuid,
    pub username: String,
    pub content: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}
pub async fn create_comment<'e, E>(
    db: E,
    create_comment_info: CreateCommentInfo,
) -> Result<CreateCommentRow, sqlx::Error>
where
    E: sqlx::Executor<'e, Database = sqlx::Postgres>,
{
    let rec: CreateCommentRow = sqlx::query_as(
            "
with inserted_comment as (
    insert into comment(user_id, post_id, content)
    values ($1, $2, $3)
    returning comment_id, user_id, content, created_at
)
select comment_id, username, content, created_at
from inserted_comment
inner join \"user\" using (user_id)
",
        )
        .bind(create_comment_info.user_id)
        .bind(create_comment_info.post_id)
        .bind(create_comment_info.content)
        .fetch_one(db)
        .await?;
    Ok(rec)
}
#[derive(Debug, Clone, sqlx::FromRow)]
pub struct GetCommentsRow {
    pub comment_id: uuid::Uuid,
    pub username: String,
    pub content: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}
pub async fn get_comments<'e, E>(
    db: E,
    post_id: uuid::Uuid,
) -> Result<Vec<GetCommentsRow>, sqlx::Error>
where
    E: sqlx::Executor<'e, Database = sqlx::Postgres>,
{
    let rec: Vec<GetCommentsRow> = sqlx::query_as(
            "
select comment_id, username, content, created_at
from comment
inner join \"user\" using (user_id)
where post_id = $1
order by created_at
",
        )
        .bind(post_id)
        .fetch_all(db)
        .await?;
    Ok(rec)
}
pub async fn create_user<'e, E>(
    db: E,
    username: String,
    password_hash: String,
) -> Result<(), sqlx::Error>
where
    E: sqlx::Executor<'e, Database = sqlx::Postgres>,
{
    sqlx::query("
insert into \"user\"(username, password_hash)
values ($1, $2)
"
    )
        .bind(username)
        .bind(password_hash)
        .execute(db)
        .await?;
    Ok(())
}
#[derive(Debug, Clone, sqlx::FromRow)]
pub struct GetUserByUsernameRow {
    pub user_id: uuid::Uuid,
    pub password_hash: String,
}
pub async fn get_user_by_username<'e, E>(
    db: E,
    username: String,
) -> Result<GetUserByUsernameRow, sqlx::Error>
where
    E: sqlx::Executor<'e, Database = sqlx::Postgres>,
{
    let rec: GetUserByUsernameRow = sqlx::query_as(
            "
select user_id, password_hash from \"user\" where username = $1
",
        )
        .bind(username)
        .fetch_one(db)
        .await?;
    Ok(rec)
}
